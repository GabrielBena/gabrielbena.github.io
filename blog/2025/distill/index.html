<!doctype html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> A Path to Universal Neural Cellular Automata | Gabriel B√©na </title> <meta name="author" content="Gabriel B√©na"> <meta name="description" content="Exploring how neural cellular automata can develop continuous universal computation through training by gradient descent"> <meta name="keywords" content="Modularity, Spiking Neural Networks, Neural Cellular Automata"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåª</text></svg>" > <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://gabrielbena.github.io/blog/2025/distill/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> </head> <d-front-matter> <script async type="text/json">
      {
            "title": "A Path to Universal Neural Cellular Automata",
            "description": "Exploring how neural cellular automata can develop continuous universal computation through training by gradient descent",
            "published": "May 12, 2025",
            "authors": [
              
              {
                "author": "Gabriel B√©na",
                "authorURL": "https://gabrielbena.github.io/",
                "affiliations": [
                  {
                    "name": "Imperial College London",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="./"> <span class="font-weight-bold">Gabriel</span> B√©na </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>A Path to Universal Neural Cellular Automata</h1> <p>Exploring how neural cellular automata can develop continuous universal computation through training by gradient descent</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#related-work">Related Work</a> </div> <div> <a href="#methods">Methods</a> </div> <ul> <li> <a href="#general-setup">General Setup</a> </li> <li> <a href="#neural-cellular-automata">Neural Cellular Automata</a> </li> <li> <a href="#hardware-immutable-state">Hardware (Immutable State)</a> </li> <li> <a href="#tasks">Tasks</a> </li> <li> <a href="#training">Training</a> </li> </ul> <div> <a href="#experiments-and-results">Experiments and Results</a> </div> <ul> <li> <a href="#task-training">Task Training</a> </li> <li> <a href="#mnist-classifier-emulation">MNIST Classifier emulation</a> </li> <li> <a href="#future-directions-graph-based-task-representations-and-neural-compilation">Future directions - Graph-based task representations and Neural Compilation.</a> </li> </ul> <div> <a href="#conclusion">Conclusion</a> </div> </nav> </d-contents> <h1 id="a-path-to-universal-neural-cellular-automata">A Path to Universal Neural Cellular Automata</h1> <p>Cellular automata have long been celebrated for their ability to generate complex behaviors from simple, local rules, with well-known discrete models like Conway‚Äôs Game of Life proven capable of universal computation.</p> <p>Recent advancements have extended cellular automata into continuous domains, raising the question of whether these systems retain the capacity for universal computation.</p> <p>In parallel, neural cellular automata have emerged as a powerful paradigm where rules are learned via gradient descent rather than manually designed.</p> <p>This work explores the potential of neural cellular automata to develop a continuous Universal Cellular Automaton through training by gradient descent.</p> <p>We introduce a cellular automaton model, objective functions and training strategies to guide neural cellular automata toward universal computation in a continuous setting.</p> <p>Our experiments demonstrate the successful training of fundamental computational primitives ‚Äî such as matrix multiplication and transposition ‚Äî culminating in the emulation of a neural network solving the MNIST digit classification task directly within the cellular automata state.</p> <p>These results represent a foundational step toward realizing analog general-purpose computers, with implications for understanding universal computation in continuous dynamics and advancing the automated discovery of complex cellular automata behaviors via machine learning.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/grant_task_evolution-480.webp 480w,/assets/unca/grant_task_evolution-800.webp 800w,/assets/unca/grant_task_evolution-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/grant_task_evolution.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Our framework performs matrix operations (translation, multiplication, rotation) through continuous cellular interactions evolving over time (from t=0 to t=60). The inset reveals the core mechanism: cells communicating only with neighbors, and interacting with a local fixed (but learned) heterogeneous substrate, are able to collectively solve mathematical tasks without explicit algorithms. </div> <h2 id="introduction">Introduction</h2> <p>Cellular Automata (CA) represent a fascinating class of computational models that have captivated researchers across disciplines for their ability to produce complex behaviors from simple rules <d-cite key="computational_beauty"></d-cite>.</p> <p>At their core, CA typically consist of a grid of cells, each in one of a finite number of states, which evolve over discrete time steps based on a fixed deterministic rule.</p> <p>This rule, applied uniformly to all cells, governs the state transition of each cell based solely on its current state and those of its neighbors.</p> <p>Despite their simplicity, CA have become a cornerstone in studying emergence and complexity <d-cite key="wolfram_cellular_1984"></d-cite>.</p> <p>Mathematical proofs have established that well-known CA, such as Conway‚Äôs Game of Life, Elementary Cellular Automata, and Wireworld, are capable of universal computation, underscoring their remarkable power and expressiveness <d-cite key="cook,life_turing_2016"></d-cite>.</p> <p>Beyond these formal demonstrations, researchers have constructed fully functional Turing machines within these CA, albeit through arduous efforts requiring meticulous design and substantial time investment.</p> <p>In recent years, the development of continuous CA has enabled to bridge the gap between the discrete nature of traditional models like Conway‚Äôs Game of Life and the analog characteristics of the real world.</p> <p>Notable examples include Lenia <d-cite key="lenia"></d-cite> and SmoothLife <d-cite key="smoothlife"></d-cite>, which extend classic CA to simulate lifelike patterns with continuous dynamics.</p> <p>However, a key open question persists: are these models capable of universal computation? While the answer is likely affirmative, given their expressive potential, proving this remains elusive.</p> <p>The lack of discrete states and well-defined transitions makes it harder to encode symbolic information reliably ‚Äî slight perturbations can lead to significant divergence over time, undermining the stability required for computation. Moreover, in contrast to the sharp boundaries and interactions of traditional CA, continuous models often exhibit smooth, fuzzy dynamics that make it challenging to design modular components like wires, gates, or memory elements with predictable behavior.</p> <p>What was already a laborious task in discrete CA becomes more difficult, if not practically impossible, in the continuous domain, highlighting a fundamental challenge in building efficient analog computers.</p> <p>In parallel with these developments, Neural Cellular Automata (NCA) have emerged as a compelling paradigm that blends the local, decentralized dynamics of classical CA with the representational capacity and trainability of neural networks <d-cite key="nca"></d-cite>.</p> <p>Unlike traditional CA, where the update rule is explicitly handcrafted, NCA leverage differentiable architectures wherein the rule is parameterized by a neural network and optimized end-to-end via gradient descent. This makes it possible to <em>learn</em> complex behaviors and dynamics from data, bypassing the need for manual rule design.</p> <p>Recent work has demonstrated that NCA can be trained to perform a wide range of tasks: from self-organizing into complex morphologies <d-cite key="nca"></d-cite>, to solving algorithmic reasoning tasks such as instances of the 1D-ARC challenge <d-cite key="cax"></d-cite>, exhibiting emergent collective behaviors <d-cite key="self_classifying"></d-cite>, and growing artificial neural networks <d-cite key="hypernca"></d-cite>. These results highlight the versatility of NCA as a model of computation and pattern formation.</p> <p>Given the Turing completeness of classical CA, NCA offer an exciting new lens through which to explore the space of rules ‚Äî not by manually engineering them, but by searching for them through optimization. In essence, NCA turn rule discovery into a machine learning problem.</p> <p>This shift is significant: the traditionally arduous task of hand-crafting rule sets that give rise to desired behaviors is now offloaded to the learning algorithm itself. Backpropagation through time, combined with the differentiable nature of NCA, allows for flexible, automated tuning of highly non-trivial dynamics.</p> <p>In this work, we explore the potential of the Neural Cellular Automata paradigm to pioneer the development of a continuous Universal Cellular Automata <d-cite key="universal_ca"></d-cite>, with the ambitious goal of inducing a universal Turing machine <d-cite key="universal_turing_machine"></d-cite> to emerge within a continuous CA through training via gradient descent.</p> <p>The development of Universal Neural Cellular Automata has implications beyond academic curiosity or creating interesting simulations. It touches on fundamental questions about the potential for continuous dynamic systems to exhibit universal computation, or the possibility to create a universal analog computer.</p> <p>This paper establishes the foundational framework and presents promising initial steps toward realizing this grand vision.</p> <p>First, we propose a novel framework that disentangles the concepts of ‚Äúhardware‚Äù and ‚Äústate‚Äù within NCA. In this abstraction, CA rules serve as the ‚Äúphysics‚Äù dictating state transitions across space and time, akin to the fundamental laws governing computation. The CA state, in turn, acts as the dynamic physical substrate ‚Äî comparable to electrical charges in a computer or neurochemical patterns in a brain‚Äîwhile the ‚Äúhardware‚Äù represents an immutable scaffold, fixed in its spatial configuration throughout a simulation. This hardware can be leveraged by the physics (i.e., the CA rules) to guide computation but remains unalterable during runtime, providing a stable backbone for emergent behaviors.</p> <p>Second, we introduce preliminary objective functions and training setups designed to steer NCA toward universal computation in a continuous domain.</p> <p>Third, we conduct experiments demonstrating the training of essential computational building blocks ‚Äî such as matrix multiplication, dot-product and transposition ‚Äî within the NCA framework.</p> <p>Finally, we showcase the practical utility of these building blocks by emulating a neural network directly within the mutable CA state, successfully solving the MNIST digit classification task.</p> <p>These results mark a critical first step, illustrating how NCA can harness gradient descent to sculpt continuous CA into powerful, general-purpose computational systems.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/architecture-480.webp 480w,/assets/unca/architecture-800.webp 800w,/assets/unca/architecture-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/architecture.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Schematic of our architecture, showing the distinction between mutable (computational) and immutable (hardware) states. </div> <h2 id="related-work">Related Work</h2> <p>Discrete CA have long been a cornerstone for studying universal computation due to their ability to generate complex behaviors from simple, local rules. A number of discrete CA, such as Conway‚Äôs Game of Life <d-cite key="cgol,life_turing_2016"></d-cite>, Rule 110 of Elementary Cellular Automata <d-cite key="wolfram,cook"></d-cite>, Langton‚Äôs Ant <d-cite key="langton"></d-cite>, and Wireworld <d-cite key="wireworld"></d-cite> have all been proven Turing-complete. These works rely on discrete states and labor-intensive, hand-crafted designs. To mitigate this, evolutionary algorithms have been employed to automate the discovery of CA rules or patterns with specific properties <d-cite key="mitchell,sapin"></d-cite>, reducing human effort though still targeting discrete systems and predefined goals rather than general-purpose computation.</p> <p>The shift to continuous CA aims to connect discrete models with real-world analog systems, prompting inquiries into their computational potential. Models like Lenia <d-cite key="lenia"></d-cite> and SmoothLife <d-cite key="smoothlife"></d-cite> introduce smooth state transitions, yielding lifelike emergent patterns, yet their capacity for universal computation remains unproven. Recent efforts have applied evolutionary search to Lenia <d-cite key="reinke_intrinsically_2020,leniabreeder"></d-cite> to automatically discover and optimize patterns, though these pursuits prioritize specific behaviors over general-purpose computation. Similarly, gradient descent has been used on Lenia patterns and rules to discover and optimize patterns <d-cite key="hamon_discovering_2024"></d-cite>, though again not targeting general-purpose computation.</p> <p>NCA mark a paradigm shift by replacing hand-crafted rules with neural networks trained via gradient descent. NCA have been successfully applied to specific tasks such as morphogenesis <d-cite key="nca"></d-cite>, classification <d-cite key="self_classifying"></d-cite>, and solving difficult problems like the 1D-ARC challenge <d-cite key="cax"></d-cite>. Most relevant to our work, HyperNCA <d-cite key="hypernca"></d-cite> uses NCA to grow artificial neural networks, suggesting broader computational versatility. These advances highlight NCA‚Äôs strength in automating rule discovery, offloading the burden of manual design to machine learning. Nevertheless, prior NCA research predominantly focuses on pattern formation or specific tasks.</p> <p>Our research intersects with analog computing and particularly neuromorphic approaches that bridge biology and silicon. Analog computation utilizes continuous physical systems, and leverages physical phenomena such as wave propagation, diffusion, and material properties to represent and transform information continuously, avoiding the quantization overhead of digital systems <d-cite key="Ulmann+2022"></d-cite>. NCAs draw inspiration from biological neural networks, which primarily employ local computations for energy efficiency <d-cite key="small_world,modular_brain,Bullmore2012TheEO"></d-cite>. This principle of locality is fundamental to both systems, and demonstrates that sophisticated computation can emerge from simple, localized rules without requiring global connectivity.</p> <p>The brain‚Äôs co-location of computation and memory offers a solution to the von Neumann bottleneck that increasingly limits conventional computing systems as model complexity grows <d-cite key="bottlneck"></d-cite>. Neuromorphic systems implement this biological principle through distributed processing elements with local memory, often using mixed-signal circuits that approximate neural dynamics while maintaining energy efficiency <d-cite key="neuromorphic_mead,neuromorphic_review,schuman2017surveyneuromorphiccomputingneural"></d-cite>.</p> <p>While deep learning has flourished through hardware-software co-design optimized for parallel matrix operations, this specialization has simultaneously restricted algorithmic innovation to operations aligned with current hardware capabilities. By exploring how systems with local interactions like NCAs can implement universal computation, we can develop more versatile computing architectures that maintain the locality constraints of biological systems while leveraging silicon‚Äôs speed advantages. This approach may yield computing systems that better balance computational power with the remarkable efficiency and adaptability characteristic of biological intelligence.</p> <h2 id="methods">Methods</h2> <p>We leverage the CAX <d-cite key="cax"></d-cite> library for high-performance neural cellular automata implementions and run our experiments on a single L40 GPU.</p> <h3 id="general-setup">General Setup</h3> <p>The goal of our framework is to demonstrate the ability of neural cellular automata to act as a general computational substrate. To do so, we tackle a variety of tasks, directly in the NCA state (see Tasks section). In this work, we introduce a novel architecture design that enhances such computational capabilities. Our approach partitions the NCA state space into two distinct components.</p> <ul> <li>The mutable state: this serves as the main workspace (where the tasks inputs are transformed into their outputs). This state is the only one changing through time during a single experiment / task roll-out. This is the computational substrate, meaning that tasks (such as matrix operations) are directly embedded in this space, and transformations on inputs have to happen in this state. The update dynamics of the mutable state are governed by the NCA rules, described in the NCA section.</li> <li>The immutable state: this functions as a specialized hardware configuration which is spatially heterogeneous. This hardware can itself be monolithic (the same shape of the entire grid) or modular (created from different specialized components for each task specific instance). This is learned across training but fixed in any duration of a single experiment / task instance. Details are specified in the Hardware section.</li> </ul> <p>Overall, this framework enables a two-level optimization strategy: At the global level, we train a general-purpose NCA rule (perceive and update functions) to support diverse computational operations. At the task-specific level, we optimize individual hardware configurations.</p> <p>The system achieves task-specific computation by adapting its dynamics using the local available hardware (reminiscent of placing the correct components on a motherboard). From an efficiency perspective, this architecture also provides significant practical advantages: once the general NCA rule is trained, adapting the system to new tasks requires only the optimization of hardware configurations, a process that is substantially less computationally intensive than training the full NCA rule from scratch. Full training details are described in the Training section.</p> <h3 id="neural-cellular-automata">Neural Cellular Automata</h3> <p>We develop computational models that solve tasks directly within their mutable state, with dynamics governed by local cell interactions. These interactions are parametrized by a neural network serving as the cellular automaton‚Äôs rules. The two key components of this neural network are its perception function and update function.</p> <h4 id="perceive-function">Perceive Function</h4> <p>The perceive function gathers information about each cell‚Äôs neighborhood through learnable convolution filters applied to the immediate vicinity within the mutable state. This perception module transforms input state channels into a higher-dimensional perception vector, capturing relevant local spatial patterns. The kernel size, padding, and activation functions are configurable hyperparameters.</p> <h4 id="update-function">Update Function</h4> <p>The update function utilizes the perception vector and local hardware vector to update each cell‚Äôs state. Our architecture employs an attention-based update module that calculates state update $\Delta S$ by conditioning perceived information $P$ on an external input vector $I$, which encodes task-specific information or global context (in our implementation, representing local cell hardware).</p> <p>The attention mechanism computes weights $\alpha$ over $N$ distinct processing heads using the input $I$: $\alpha = \text{softmax}((I \cdot W_{\text{embed}}) / T)$, where $W_{\text{embed}}$ is an embedding matrix and $T$ is a temperature parameter. Concurrently, the perception vector $P$ is processed through $N$ parallel pathways, typically implemented as multi-layer perceptrons (MLPs), generating potential update vectors $V_h$ for each head. The final state update is computed as: $\Delta S = \sum_{h=1}^{N} \alpha_h V_h$, with the cell‚Äôs state updated residually: $S_{t+1} = S_t + \Delta S$.</p> <p>This mechanism enables the NCA‚Äôs local rule to dynamically adapt based on the provided local substrate. The resulting models demonstrate versatility in performing diverse computations using the same underlying cellular update rule, exhibiting emergent information routing and processing capabilities arising solely from local cell interactions and their heterogeneous substrate: what we describe as the NCA‚Äôs hardware.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/monolithic_hw-480.webp 480w,/assets/unca/monolithic_hw-800.webp 800w,/assets/unca/monolithic_hw-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/monolithic_hw.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Monolithic hardware configurations for 3 different sub-tasks </div> <h4 id="modular-hardware">Modular hardware</h4> <p>To address the limitations of monolithic hardware, we developed a modular and composable approach. Similar to how specialized components on a motherboard emulate desired behavior, we train three purpose-specific hardware <em>components</em>:</p> <ol> <li>An input embedding vector specifying cells that receive inputs in the computational task. Cells whose mutable state receives inputs include this vector in their immutable state.</li> <li>An output embedding vector marking cells that will serve as output during a specific task.</li> <li>A task embedding vector enabling the NCA to recognize the type of input-output transformation required. This learned vector is added to every cell‚Äôs hardware state.</li> </ol> <p>These three core components are then manually assembled for each task instance to create specific task examples. The resulting immutable state remains accessible to the update rule throughout an experiment. This modular approach balances the scale-free nature of NCAs with the need for local heterogeneous substrate to perform diverse computational tasks. We also demonstrate that this enables zero-shot generalization, allowing the NCA to perform unseen task configurations and even composite task chaining (see Future directions section).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/modular_hw-480.webp 480w,/assets/unca/modular_hw-800.webp 800w,/assets/unca/modular_hw-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/modular_hw.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Modular hardware configurations for 3 different sub-tasks, and different matrix sizes and placement </div> <h4 id="graph-based-hardware-hypernetwork-wip">Graph-based hardware hypernetwork (WIP)</h4> <p>Finally, building upon the limitations of the previous hardware approaches, we are currently developing a more principled graph-based hardware generation framework that should offer significant improvements in both flexibility and scale-invariance. This approach leverages a task representation abstraction where computational operations are modelled as a graph, with nodes representing input and output regions and edges encoding specific transformations between them.</p> <p>At the core of this framework is a Hardware Meta-Network consisting of two main components: a Graph Neural Network (GNN) encoder and a coordinate-based hypernetwork:</p> <ul> <li>The GNN processes a task graph structure, where nodes contain normalized spatial information about input and output regions, and edges represent specific operations (e.g., matrix multiplication, rotation) to be performed between regions. Through multiple message-passing layers, the GNN distills this graph representation into a fixed-dimensional latent task vector that captures the essential computational requirements of a single task instance problem.</li> <li>This latent representation then conditions a coordinate MLP hypernetwork that generates hardware vectors for every spatial location in a scale-free manner. The hypernetwork leverages positional encodings to create spatially varying hardware patterns that guide the NCA‚Äôs computational dynamics across the grid. Crucially, this approach maintains exact spatial invariance: task specifications are normalized relative to grid dimensions, which should enable the generated hardware to automatically adapt to different grid sizes and region placements without retraining.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/hardware_meta_network-480.webp 480w,/assets/unca/hardware_meta_network-800.webp 800w,/assets/unca/hardware_meta_network-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/hardware_meta_network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Graph-based tasks representations and GNN-based hypernetwork for hardware generation </div> <p>This graph-based representation provides an intuitive interface between human-specified computational tasks and the continuous NCA substrate. Users can define tasks through a natural graph specification (inputs, outputs, and operations), and the meta-network translates these specifications into appropriate hardware configurations. This approach would effectively improve on the concept of a compiler between human intent and the NCA‚Äôs computational capabilities, allowing for better definition of task chaining and temporal hardware evolution.</p> <p>Moreover, the graph structure can enable rich extensions beyond our initial implementation. Tasks can be ordered through edge attributes, allowing sequential execution planning. Dynamic hardware reconfiguration becomes possible by modifying the task graph over time, creating a secondary dynamics layer that complements the fast neural dynamics of the cellular automaton itself. This hierarchical temporal structure, where fast neural dynamics implement local computations while slower hardware dynamics guide algorithmic flow, mirrors the dichotomy in traditional computing architectures between clock-cycle operations and higher-level program execution. Doing so within a unified differentiable framework may ultimately enable more efficient, adaptable continuous computational paradigms.</p> <h3 id="tasks">Tasks</h3> <p>To train robust and versatile Neural Cellular Automata (NCA) models capable of performing general computation, we implement a flexible framework of matrix-based operations. These tasks, exercise different computational capabilities and test the NCA‚Äôs ability to process, transform, and route information across the grid.</p> <h4 id="matrix-operations">Matrix Operations</h4> <p>The core of our framework is a set of fundamental matrix operations that represent different computational primitives:</p> <ul> <li><strong>Identity Mapping</strong>: Reproducing an input matrix at a different target location. This tests information preservation and signal routing across the grid.</li> <li><strong>Matrix Multiplication</strong>: Given input matrices $A$ and $B$, compute $C = A \times B$. This tests the NCA‚Äôs ability to perform non-local computations requiring information integration across regions.</li> <li><strong>Transposition /Rotation</strong>: Given input matrix $A$, compute $B = A^T$ (or alternatively $B = A^T_{flipped}$ representing a 90 degree rotation in the plane). This evaluates spatial information routing capabilities and geometric understanding.</li> <li><strong>Element-wise Operations</strong>: Given input matrices $A$ and $B$, compute $C = A \cdot B$. This tests the NCA‚Äôs ability to perform parallel local computations.</li> </ul> <h4 id="diverse-input-distributions">Diverse Input Distributions</h4> <p>To prevent overfitting to specific input patterns, we employ matrices with varied statistical properties:</p> <ul> <li><strong>Uniform and Gaussian Distributions</strong>: Randomly distributed matrix values test general processing capabilities.</li> <li><strong>Spatially Correlated Patterns</strong>: Self-similar patterns with spatial correlations test the NCA‚Äôs ability to process structured information and recognize spatial relationships.</li> <li><strong>Discrete-Valued Matrices</strong>: Matrices containing only a limited set of discrete values test the NCA‚Äôs ability to process categorical information.</li> <li><strong>Sparse Representations</strong>: Matrices where most elements are close to zero test the NCA‚Äôs efficiency in handling information sparsity.</li> </ul> <h4 id="flexible-placement-and-size">Flexible Placement and Size</h4> <p>To ensure the NCA develops robust computational abilities that generalize beyond fixed spatial arrangements, we include in the task framework:</p> <ul> <li><strong>Dynamic Placement</strong>: Input and output matrices can be positioned at different locations within the grid, preventing the NCA from memorizing fixed spatial patterns and forcing it to develop general computation mechanisms.</li> <li><strong>Variable Matrix Sizes</strong>: Tasks involve matrices of different dimensions, from small to large relative to the grid size, testing the NCA‚Äôs ability to scale its computations and adapt to varying information densities.</li> <li><strong>Multiple Inputs and Outputs</strong>: Tasks can involve multiple input and output matrices distributed throughout the grid, requiring the NCA to coordinate information flow between different regions and perform parallel processing.</li> </ul> <p>(This flexible task placement scheme is only usable in conjunction with a <em>modular</em> hardware configuration, as discussed in the Hardware section)</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/mnist-480.webp 480w,/assets/unca/mnist-800.webp 800w,/assets/unca/mnist-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/mnist.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> NCAs as a neural network emulator. Inputs show a batch of flattened MNIST images, alongside the weight matrix of a pre-trained single-layer linear classifier. We decompose this matrix multiplication into sub-blocks, that can be directly emulated in parallel by the NCA. Results are fetched from NCA states and aggregated back into logits, of size batch x 10 (figure shows the first 32 outputs only for readability). We compute accuracy by taking the logits argmax per batch and comparing with labels. </div> <h3 id="training">Training</h3> <p>To equip our Neural Cellular Automaton (NCA) with the capacity to perform a diverse range of computational tasks, we utilize a joint training framework. This approach simultaneously optimizes a single, shared NCA rule across a collection of distinct tasks instances. Each task is defined by a specific objective (an operation to be made on the inputs), and one task instance is typically represented by an initial grid state $S_0$, a desired target final state $S_{\text{target}}$, and often a mask $M$ indicating the regions of the grid relevant for evaluation.</p> <p>During training, batches containing instances from various tasks are sampled. For each instance, the NCA model evolves the initial state $S_0$ over a defined number of discrete time steps $T_{\text{steps}}$ to produce a final state $S_{\text{final}}$. To enhance stability of the NCA, final states used to compute the loss are chosen at random between $T_{\text{steps}}$ and $T_{\text{steps}} - T_{\text{steps}} // 4$</p> <p>A loss function (commonly a masked error metric such as MSE), quantifies the discrepancy between the achieved final state and the target state within the relevant regions defined by the mask $M$.</p> <p>Gradient-based optimization is employed to minimize this loss. Parameters associated with the shared NCA rule and any shared IO hardware components (in the <em>modular</em> hardware case) are updated based on gradients aggregated across all tasks within the batch, promoting the learning of general-purpose computational primitives. Parameters belonging to task-specific modules (<em>monolithic</em> hardware, or task components in the modular case) are updated using only the gradients derived from their corresponding task instances, enabling specialized behavior. This joint optimization process encourages the emergence of a versatile NCA capable of executing multiple computational functions through its learned local dynamics, dynamically adapting its behavior based on the presented task hardware.</p> <h2 id="experiments-and-results">Experiments and Results</h2> <h3 id="task-training">Task Training</h3> <h4 id="joint-training">Joint Training</h4> <p>In a multi-task training setup, our Neural Cellular Automata successfully master various matrix operations simultaneously through a shared update rule architecture combined with task-specific hardware components. Our findings demonstrate that a single NCA can develop general computational principles that apply across different matrix tasks while maintaining the specialized parameters needed for each specific operation.</p> <p>The multi-task learning capability reveals the fundamental computational versatility of NCAs. By simultaneously learning to perform diverse operations such as matrix multiplication, translation, transposition and rotation within a unified framework, the model demonstrates mastery of a complete algebra of matrix operations‚Äîthe essential building blocks for more complex computation.</p> <p>This multi-task foundation directly enables more sophisticated composite applications, such as our MNIST classifier emulation. The ability to decompose complex operations into smaller matrix tasks and process them through the same underlying cellular mechanism demonstrates a pathway toward increasingly complex computation. By establishing that NCAs can reliably perform these fundamental operations, we provide the essential building blocks for future work on more elaborate composite tasks, including full neural network emulation, algorithmic reasoning, and potentially even more advanced computational models implemented entirely within the cellular substrate.</p> <h4 id="downstream-tasks-fine-tuning">Downstream Tasks Fine-tuning</h4> <p>A key advantage of our architecture emerges once the NCA is pre-trained: new tasks can be accommodated by fine-tuning only the hardware configurations while keeping the core CA update rules frozen. This approach significantly reduces computational requirements for adaptation to novel tasks. In our experiments, fine-tuning hardware alone increases training speed by a factor 2, compared to full model retraining. A more comprehensive comparison of joint training vs fine-tuning is nevertheless needed.</p> <h3 id="mnist-classifier-emulation">MNIST Classifier emulation</h3> <p>We demonstrate a practical downstream application by using our Neural Cellular Automata (NCA) to emulate an entire neural network directly in its computational workspace. Specifically, we emulate a single-layer Multi-Layer Perceptron (MLP) solving the MNIST digit classification task.</p> <p>First, we pre-train a simple linear feedforward network to classify MNIST digits with sufficient accuracy. This classifier uses a single weight matrix without bias terms, where inference requires only a matrix multiplication between the flattened input images and the weight matrix, followed by an argmax operation to determine the predicted digit.</p> <p>Our NCA model was pre-trained as well, on smaller 8√ó8 matrix multiplication tasks. While we could hope for generalization to larger matrices, operations of the scale required for MNIST classification (784√ó10) would exceed the capacity of what can be performed by such a model. To address this limitation, we implement block-matrix decomposition, fragmenting the classification of MNIST images into multiple smaller 8√ó8 matrix operations that fit within the NCA‚Äôs state constraints.</p> <p>The resulting decomposed operations can be executed directly within the NCA‚Äôs computational state without requiring task-specific fine-tuning, demonstrating the robustness of our approach to novel matrix distributions. The NCA processes each block multiplication operation in parallel, after which we aggregate the results to reconstruct the complete classification logits.</p> <p>When evaluating performance, we compare the predictions and accuracy of our NCA-based emulation against the original classifier. While we observe some accuracy degradation due to error propagation across numerous sub-operations, the model still achieves respectable performance (around $60\%$ accuracy for the emulated classification compared to $84\%$ for the original, with predictions agreeing around $69\%$ of the time). We argue that this is providing empirical evidence that neural network emulation via NCA is feasible.</p> <p>This research has significant implications for analog and physical computing. If our NCA‚Äôs update rules were implemented as physical state transitions, this would represent a pathway toward physical neural network emulation without reverting to binary-level operations. The ability to operate directly at the level of matrix operations using hardware specifically designed for this computational paradigm could offer substantial efficiency and performance improvements over conventional digital approaches.</p> <h3 id="future-directions-task-composition-and-neural-compiler">Future directions: task composition and neural compiler</h3> <p>The modular hardware configuration we developed enables straightforward creation of out-of-distribution tasks through component composition. This flexibility allows us to design novel computational scenarios that the NCA was not explicitly trained on, yet can still execute successfully.</p> <p>For instance, we can implement data distribution patterns by duplicating a central matrix into multiple corners using the matrix translation task embedding and multiple target tiles. This simple example demonstrates how our architecture supports operations beyond the training distribution without requiring additional training.</p> <p>This framework opens the path toward complex composite tasks created through sequential chaining of primitive operations. Consider the following multi-step procedure:</p> <ol> <li>Start with a input matrix and distribute copies to two corner positions using target tiles.</li> <li>Replace the current hardware configuration with new parameters that redefine these targets as inputs, then perform matrix multiplication towards a third corner.</li> <li>Update the hardware again to rotate the resulting matrix and return it to the original position.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/OOD-480.webp 480w,/assets/unca/OOD-800.webp 800w,/assets/unca/OOD-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/OOD.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Examples of an Out of Distribution Task: the NCA needs to distribute a matrix in all corners in a larger grid than the one seen during training. </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/unca/compiler-480.webp 480w,/assets/unca/compiler-800.webp 800w,/assets/unca/compiler-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/unca/compiler.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Illustrating composite computational tasks using modular hardware configurations. Top panel: Multi-Rotation Sequential rotations resolving in the identity function. Bottom panel: Distribute-Multiply-Rotate task, showing a three-step process where matrices are distributed, multiplied, and rotated to achieve the target state. Each step shows both the hardware configuration and corresponding computational states. </div> <p>While such composite sequences may not appear useful on their own, they demonstrate a critical capability: the NCA can execute complex algorithmic workflows through sequential reconfiguration of its hardware parameters. This capability lays the groundwork for more sophisticated computational reasoning and abstraction.</p> <p>This composite task chaining also highlights the crucial role of stability in achieving composable computations. When outputs produced within the NCA‚Äôs computational state serve as inputs for subsequent operations, establishing stable representations becomes essential. In parallel to biological systems, where homeostasis maintains internal equilibrium despite external changes, NCAs require a form of computational homeostasis to maintain reliable state representations between operations. Similarly, analog computing systems may require material homeostasis to successfully implement extended chains of tasks and computations without degradation of information.</p> <p>We propose that this sequential operation model suggests a compelling dual-timestep approach to neural compilation: At the neuronal timestep, the NCA‚Äôs mutable state evolves according to its update rules, creating the fundamental dynamics of computation. At the compiler timestep, hardware parameters are reconfigured to provide task abstractions and high-level procedural steps. This separation of concerns, where fast neuronal dynamics handle computation while slower hardware changes control program flow, mirrors classical computer architecture but within a continuous, differentiable substrate. As this approach matures, it could enable direct compilation of algorithms into neural cellular automata, combining the flexibility of neural networks with the precision of programmatic execution.</p> <h2 id="conclusion">Conclusion</h2> <p>The exploration of universal computation within cellular automata has historically been confined to discrete systems, where models like Conway‚Äôs Game of Life and Elementary Cellular Automata have demonstrated the remarkable ability to emulate Universal Turing Machines. However, extending this capability to continuous cellular automata presents significant challenges, primarily due to the absence of discrete states and the inherent instability of smooth, analog dynamics. In this work, we have taken pragmatic first steps toward overcoming these hurdles by leveraging NCA as a substrate for developing universal computation in a continuous domain. By employing gradient descent to train NCA rules, we have demonstrated a pathway to sculpt complex computational behaviors without the need for manual rule design, shifting the burden of discovery from human ingenuity to machine learning.</p> <p>Our results illustrate that NCA can successfully encode fundamental computational primitives, such as matrix multiplication and inversion, and even emulate a neural network capable of solving the MNIST digit classification task directly within its state. These findings suggest that NCAs can serve as a bridge between traditional computing architectures and self-organizing systems, offering a novel computational paradigm that aligns closely with analog hardware systems. This linkage is particularly promising for designing efficient computational frameworks for AI models operating under constrained resources, where energy efficiency and robustness are paramount. Rather than training entirely new rules for each task, our approach hints at the possibility of discovering optimal hardware configurations that exploit the fixed physical laws governing these substrates, enabling meaningful computations with minimal overhead.</p> <p>Looking forward, we believe this work lays the groundwork for transformative advancements in computational science. By automating the discovery of general-purpose computers within diverse physical implementations, NCA could revolutionize how we harness novel materials and systems for computation, potentially leading to ultra-efficient analog hardware systems or computational paradigms that scale linearly with resource demands. While challenges remain ‚Äî such as stabilizing continuous dynamics for reliable symbolic encoding and scaling these systems to more complex tasks‚Äîthe potential of NCA to unlock universal computation in continuous cellular automata opens new avenues for exploration. Ultimately, this research not only advances our understanding of computation in continuous dynamics but also paves the way for the next generation of adaptive, energy-efficient computing technologies.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/unca.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'GabrielBena/gabrielbena.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript">comments powered by giscus.</a></noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> &copy; Copyright 2025 Gabriel B√©na. Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hideBreadcrumbs noAutoLoadMdIcons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>